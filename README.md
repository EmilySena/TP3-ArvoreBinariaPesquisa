# TP3-ArvoreBinariaPesquisa
 **Trabalho Prático 3: As mensagens  secretas da Aliança Rebelde **
**Estrutura de dados - 2020/1**

**1. Introdução**
	O objetivo deste programa é ajudar a Aliança Rebelde a enviar e receber mensagens criptografadas de modo a evitar que as mensagens sejam entendidas pelas forças do Darth Vader, caso alguma mensagem seja interceptada. Assim, o que foi desenvolvido foi uma forma de automatizar esse processo de encriptação e decriptação das mensagens para a Aliança Rebelde. Para implementar esse sistema foi utilizada uma árvore binária, e os detalhes dessa implementação seram abordados adiante.
**2. Implementação**
	O programa foi implementado utilizando-se a linguagem de programação C++, com o uso de programação orientada a objetos, classes e algumas estruturas de dados. 
**2.1 Estrutura de Dados**
	A implementação do programa teve como base a estrutura de dados da Árvore Binária de Pesquisa. Essa estrutura era a mais adequada para a implementação pois permitiria que as palavras fossem armazenadas e uma chave fosse associada a cada uma, facilitando assim o processo de encriptação e decriptação da mensagem. O que define uma árvore binária T como uma árvore binária de pesquisa é: 
→  Chaves da subárvore esquerda de T são menores do que chave da raiz de T;
→ Chaves da subárvore da direita de T são maiores do que a chave da raiz de T;
→ Subárvores da esquerda e da direita de T são árvores binárias de pesquisa.
	No caso, desse TP, as palavras da língua seriam inseridas na árvore binária. Para a inserção é considerado a ordem alfábetica, ou seja se a raiz é a palavra “bola”, e são inseridas as palavras “abacaxi” e “casa”, então “abacaxi” ficará à esquerda da raiz, enquanto a outra palavra ficará à direita. E a chave que seria associada a cada palavra seria a sua posição, caso fosse feito o caminhamento pré-ordem nessa árvore, correspondendo então a um número inteiro. 
	Essa estrutura foi implementada a partir de classes, que serão descritas adiante.
**2.2 Classes**
**2.2.1 Tipo Item**
	Essa classe foi criada para armazenar uma palavra e sua chave, e corresponde ao que é armazenado em cada nó da árvore binária. Nesse classe foram implementados seu contrutor, destrutor, os Getters e Setters para a palavra, que é uma string, e para sua chave que corresponde a um inteiro. Além desses métodos, foi criado um método ImprimeChave para imprimir a chave, e um ImprimePalavra, para imprimir a palavra.
**2.2.2 Node**
	Essa classe corresponde aos nós da árvore. Sendo assim, foi declarada como uma friend class da classe ArvoreBinaria. O Node, possui seu construtor como método público. Como privado, tem um TipoItem, que é o que vai ser armazenado dentro do nó da árvore (a palavra e sua chave). E também dois ponteiros de Node, um para a esquerda(Esq) e outro para a direita(dir).
**2.2.3 ArvoreBinaria**
	A classe ArvoreBinaria vai se utilizar dessas duas outras classes em sua estrutura. Essa classe tem como atributo privado um ponteiro de Node, que corresponde à raiz da árvore. Possui como métodos públicos: seu contrutor(que inicia a raiz como nullptr) e seu destrutor que tem a função de remover todos os elementos da árvore, chamando o método também público, Limpa(). Essa classe possui o método privado InsereRecursivo que é chamado pelo método público Insere, e serve para inserir um elemento nessa estrutura. Para inserir um elemento, é usado a recursividade, dividindo em dois lados, o direito e o esquerdo, através do uso de esq e dir que são os ponteiros de Node.
	O método Insere, apenas adiciona outro Node à estrutura, mas o TipoItem desse Node terá definido apenas a palavra(string), pois é isso que ele recebe de parâmetro e precisamos associar uma chave(int) a essa palavra. Como a chave associada corresponde a posição dessa palavra na estrutura caso fosse feito um caminhamento pré-ordem, para fazer essa associação chave→ palavra, implementei o caminhamento pré ordem, e enquanto é feito esse caminhamento há um contador que vai ser igual a chave que deve ser associada àquele elemento. Dessa forma, sempre que um objeto do tipo ArvoreBinaria mudar(através de uma inserção de um elemento ou remoção), é necessário chamar esse método para setar novamente as chaves. Assim, eu implementei o método privado PreOrdemChave que tem como parametros um ponteiro de Node e um int que é passado como referência, esse int vai ser o contador. Esse método é chamado pelo método público, Caminha(), onde o contador é declarado e inciado com 1, e o PreOrdemChave() é chamado com os parâmetros, raiz, que onde vai começar, e com um inteiro, que é o contador.
	Há também o método Pesquisa que retorna um TipoItem e tem como parametro a palavra a ser pesquisada. Esse método chama o método PesquisaRecursivo, com os parâmetros, que são a palavra a ser pesquisada (string) e um ponteiro de Node que é a raiz. O método PesquisaRecursivo, como o nome já sugere se utiliza da recursividade para pesquisar o item dentro da estrutura. Divide-se a estrutura, procurando do lado esquerdo, caso a palavra seja menor (com menor significa vem antes da raiz, considerando a ordem alfabética). E caso a palavra seja maior do que a raiz, procura por ela do lado esquerdo. Retornando então o TipoItem da ArvoreBinaria que tem essa palavra associada a ele. E quando temos o TipoItem, temos também a chave dele e esse método será usado mais a frente para encriptar a mensagem.
	O método público Remove, serve para remover um item do objeto da classe ArvoreBinaria. Esse método recebe como parâmetro uma string que é a palavra que vai ser removida. Ele vai chamar o método privado RemoveRecursivo, com os parâmetros, um ponteiro de Node, que é a raiz, e uma string, que é a palavra a ser removida. Esse método funciona usando a recursividade. Para isso, vemos se o ponto de partida, começa com a raiz, é menor do que o termo que queremos remover, que no caso é a palavra, se for o caso, vamos procurar na sub-árvore da esquerda. E se for o contrário, se for maior, procuramos na sub-árvore da esquerda. E em ambos chamamos o método recursivamente. Para remover um nó da árvore, temos três casos: o nó é uma folha; o nó não é folha e possui uma sub-árvore; e o nó não é folha e possui duas sub-árvores. Portanto, esse método vai ter que abordar esses três casos. No primeiro caso, quando o nó a ser excluído é uma folha, basta removê-lo e desalocar a memória. No segundo caso, quando o nó a ser removido possui uma sub-árvore, nesse caso, o primeiro filho, vai ocupar o lugar desse nó a ser removido. Por fim, o terceito caso, é quando o nó a ser removido possui duas sub-árvores. Nesse caso, temos a função Antecessor que é chamada a fim de remover esse nó e colocar no lugar dele o nó correto.
	O método Limpa(), apaga todos os elementos da árvore e inicializa a raiz como nullptr. Para remover todos os nós da árvore, ele chama o método ApagaRecursivo, que tem como parâmetro a raiz. Esse método faz o caminhamento pré-ordem e vai apagando cada nó da estrutura.
	O método Substituindo foi criado com o objetivo de substituir uma palavra por outra, por isso recebe duas palavras(strings) como parâmetros. Esse método chama primeiro o método Remove com a palavra que vai ser removida e depois chama o método Insere com a palavra que vai ser inserida.	
	O método Desencriptando tem como objetivo receber um inteiro, que é a chave, e encontrar a palavra que é associada àquela chave. Para fazer isso, esse método, vai chamar o método PreOrdemPalavra, com os parâmetros raiz, e a chave que estamos procurando. Esse método faz o caminhamento pré-ordem na árvore e caso a chave seja igual a chave do elemento que estamos procurando, imprimimos a palavra, chamando o método ImprimePalavra da classe TipoItem.	
**2.5 Comandos possíveis**
	Foram definidos alguns comandos para fazer as operações de inserir, substituir, encriptar e desencriptar. O que era esperado de cada comando, vai ser descrito adiante.
**2.5.1 Comando i**
	Esse comando é o responsável por inserir uma nova palávra ao dicionário da língua que é a árvore binária que irá armazenar as palavras. Esse comando chama a função Inserir no main, e tem os paramêtros arvoreBinaria(nome do objeto do tipo ArvoreBinaria q vai armazenar as palavras) e uma string que é a palavra a ser inserida no dicionário. Essa função Inserir dentro dela, chama a função Insere que pertence a classe ArvoreBinaria para adicionar a palavra lida. E depois de adicionar, chama-se a função Caminha() que serve para setar as chaves a cada uma das palavras inseridas na estrutura, sendo que essa função faz o caminhamento da árvore na pré-ordem.
**2.5.2 Comando e**
	Esse comando chama a função Encriptar no main para criptografar a mensagem. Os parâmetros recebidos por essa função são a arvoreBinaria e a palavra a ser criptografada. Para criptografar, chama-se a função Pesquisa da classe ArvoreBinaria, procurando onde se encontra a palavra na arvoreBinaria. Esse método retorna um TipoItem que contém a palavra buscada e a chave associada a ela. Então para imprimir a chave associada a essa palavra, usamos o método GetChave(). Há um for que é executado até n, sendo n o numero de palavras a serem codificadas. Todas essas palavras são armazenadas no vector (do tipo string) palavras.  
**2.5.3 Comando d**
	Esse comando é para desencriptar a mensagem, e chama no main a função Desencriptar, que recebe como parâmetros o objeto arvoreBinaria e o vector de inteiros que contém as chaves a serem desencriptadas. Essa função chama dentro dela, para cada uma das chaves, em um for, chama o método Desencriptando da classe ArvoreBinaria. Esse método imprime na tela a palavra que corresponde àquela chave. 
**2.5.4 Comando s**
	Esse comando serve para substituir uma palavra que está armazenada no dicionário da língua (objeto arvoreBinária), por uma outra palavra. Este comando chama a função Substituir, que possui os parâmetros arvoreBinaria e as duas palavras lidas, a que vai ser retirada, e a que vai ser acrescentada na árvore. Essa função chama o método da classe ArvoreBinaria, Substituindo que recebe as duas palavras e executa essa tarefa de remover a primeira da árvore e inserir a segunda, chamando os métodos Remove e Insere. Depois chama o método Caminha(), para setar as chaves de novo, uma vez que a árvore mudou.
**3. Instruções de Compilação e Execução**
	O programa foi desenvolvido na linguagem C++, compilada pelo compilador  G++ da GNU Compiler Collection. Foi feito um makefile para facilitar a compilação do programa, então basta abrir o terminal no diretório Emily_Sena/src e digitar o comando “make” e depois “./tp3”. O programa foi desenvolvido e compilado no linux, então seria ideal que se compilasse nesse sistema operacional também, pois o makefile foi feito nesse contexto.
**4. Análise de Complexidade**
	Agora será analisado o estudo da complexidade de tempo e espaço do algoritmo de melhor e pior caso desenvolvido utilizando o formalismo da notação assintótica. De acordo com o que foi desenvolvido e implementado neste trabalho prático.
**4.1. Complexidade de tempo**
	Começaremos a análise com a simples adição de uma palavra, ou seja o total de palavras =1, N=1. Assim as operações realizadas, com as funções Inserir, Encriptar, Desencriptar e Substituir, teriam um custo constante, uma vez que até o caminhamento que seria o que teria o maior custo, O(n), como n =1, seria O(1), e todos os for de Encriptar e Desencriptar, só seriam executados uma única vez, uma vez que n=1. O custo disso seria de O(1), ou seja, um custo constante, pois haveria apenas uma palavra na estrutura do dicionário. E esse vai ser o melhor caso do programa.
	Logo no começo do main, tem um while que vai ser executado enquanto a variavel do tipo char denominada como “comando”, vai ler cada um dos comandos que a Aliança Rebelde quer executar, enquanto (cin>>comando), ou seja, há apenas dois casos: quando comando é == (igual) a EOF e quando não é, e portanto será um tipo char. Portanto o custo desse laço while sempre será constante e vai ser de O(1).
	Para cada comando são executadas ações na classe da estrutura de dados ArvoreBinaria, chamando os métodos Insere, Caminha(que chama o método PreOrdemChave e faz o caminhamento pré ordem na árvore), Pesquisa, Substituindo(que chama o método Insere e o Remove), e Desencriptando(que chama o PreOrdemPalavra, fazendo o caminhamento da árvore em pré-ordem e imprimindo a palavra associada àquela chave). 
	Se um procedimento descarta metade da árvore a cada iteração ou chamada e a árvore é balanceada, sua complexidade é logarítmica no tamanho da árvore, ou seja O(n). Como o procedimento dos métodos Insere, Remove e o Pesquisa em árvores binárias de pesquisa, quando executados em árvores balanceadas. Sendo assim, temos como caso médio, a complexidade para esses métodos, de O(log n). E no pior caso, que acontece em árvores degeneradas ou quando a árvore não se encontra balanceada, que vai ter complexidade de O(n).
	Se um procedimento visita todos os nodos de uma árvore, sua complexidade assintótica é linear no número de nodos da árvore. Como é o caso do caminhamento pré-ordem. Que é chamado no método Caminha(que chama o PreOrdemChave) e no Desencriptando(que chama o PreOrdemPalavra), a complexidade de ambos então sempre vai ser de O(n), no caso médio e no pior caso.
	O método Substituindo chama o método Insere e Remove, mas em iterações diferentes, e portanto sua complexidade vai ser de O(max(log n, log n)), no caso médio, e portanto O(log n). E no pior caso vai ser de O(max(n, n)), que é O(n).
	Agora analisando as funções no main, primeiro temos a função Inserir, que insere uma palavra no objeto do tipo ArvoreBinaria. Essa função chama o método Insere e chama o Caminha.  Como a complexidade do Insere no pior caso é de O(n) e do Caminha é sempre O(n), então a complexidade dessa função, no pior caso, é de O(max(n, n)), e portanto, O(n). Quando estamos no caso médio, a complexidade de Insere, é O(log n), e a complexidade dessa função vai ser de O(max(log n, n)), que também é equivalente a O(n). Assim, a complexidade dessa função é de O(n) no caso médio. E para ler as entradas do comando “i”, o custo é sempre constante, e portanto O(1).
	Depois temos a função Encriptar.  Essa função é chamada quando executamos o comando “e”. Para ler as entradas desse comando, primeiro lemos um número “k” que corresponde a quantidade de palavras que seram lidas para serem encriptadas. Depois disso temos um for que se repete k vezes, para ler cada uma das palavras. A complexidade dessa parte, será O(k), e vai variar de acordo com o valor de k. Depois chama-se a função Encriptar. Essa função chama o método Pesquisa dentro de um for que se repete por k vezes, uma vez para cada palavra. No pior caso, o método Pesquisa tem complexidade de O(n), onde n corresponde a quantidade de nós da árvore, e como ele está dentro de um laço for que se repete k vezes, então a complexidade da função Encriptar, no pior caso, vai ser de O(n*k). No caso médio, a complexidade do método pesquisa é de O(log n), e então, a complexidade de Encriptar vai ser de O(k*log n), no caso médio.
	Na função Desencriptar é chamada dentro do comando “d”, que primeiro le um número k que vai corresponder a quantidade de chaves que deveram ser desencriptadas. As chaves são lidas dentro de um for que se repete k vezes, e portanto a complexidade dessa parte vai ser de O(k). Depois temos a chamada da função Desencriptar. Dentro dela temos um for que se repete k vezes, onde chamamos o método Desencriptando. Como esse método sempre possui complexidade de O(n), pois visita todos os nós, a complexidade da função Desencriptar, vai ser a mesma no caso médio e  no pior caso, e portanto será de O(n*k).
	Na função Substituir que é chamada pelo comando “s”, onde a leitura das duas entradas, as duas palavras, possui complexidade constante que é de O(1). E esse comando chama a função Substituir. Dentro dessa função chamamos o método Substituindo da classe ArvoreBinaria e depois chamamos o método Caminha. Como já explicamos acima, o método Caminha possui complexiadade linear, O(n), e o Substituindo possui complexidade de O(n) no pior caso e de O(log n) no caso médio. Sendo assim a complexidade da função substituir, vai ser O(max(n, n)), no pior caso, e portanto O(n). E no caso médio, O(max(log n, n)), que também vai ser de O(n). E portanto a complexidade dessa função vai ser de O(n).
	Sendo assim, podemos concluir que o custo total do programa vai ter  complexidade de O(max(1,n*k)), que é O(n*k), que é uma complexidade linear, pois será n, que corresponde aos nós da árvore, vezes um certo k. E essa é uma complexidade linear, uma vez que se m=n*k, então a complexidade, pode ser escrita como O(m).
**4.2. Complexidade de espaço**
	Vamos considerar que cada nó da árvore, que contém uma palavra e sua chave, ocupe uma unidade de espaço, para a nossa análise. Assim, na pior hipótese do programa, a árvore terá um número N de nós e todos eles estarão ocupados, assim a memória alocada para o programa vai ser linear e variará conforme o valor de N, sendo N o número de nós da árvore. Por exemplo, seja N=1, a árvore possui apenas um nó, e a complexidade de espaço para esse caso será O(N). Se multiplicarmos os nós da árvore por 100, teremos, uma complexidade de espaço de O(100*N) , que ainda é linear e corresponde a O(n). Portanto a complexidade de espaço será de O(n).
**5. Conclusão**
	O objetivo deste trabalho era implementar uma árvore binária de pesquisa que armazenasse as palavras de uma língua e associasse a cada palavra uma chave que seria usada para encriptar e desencriptar uma mensagem. Talvez essa não seja a melhor forma de criptografia, uma vez que é bem simples, mas é uma forma interessante de usar a árvore binária de pesquisa. 
	Porém no desenvolvimento deste trabalho, foi possível entender melhor como funciona uma árvore binária de pesquisa, e pensar nas melhores formas de se usar esta estrutura de dados. Acredito que a parte prática é tão importante quanto a teórica para o aprendizado, uma vez que é nela que realmente temos a oportunidade de colocar a mão na massa e quebrar a cabeça para ver como tudo funciona e qual a melhor forma de implementar cada parte do problema.
	Através da análise de complexidade do programa que foi implementado, fica muito evidente também a importância de pensar atentamente em cada parte da implementação de um programa de forma a ter o menor custo possível, tanto de espaço quanto de tempo. E também nos permite ver o real custo de cada parte do nosso código, ao invés de apenas escrevermos algo sem saber realmente qual é a complexidade daquilo. Isso nos dá a oportunidade de escrever códigos melhores, e assim nos tornarmos melhores programadores. 
	Além disso, também fica evidente a importância de ter boas práticas de programação durante a escrita do código para que seja possível que outras pessoas compreendam o que escrevemos, além de quem escreveu o programa. Uma vez que a avaliação é feita por terceiros. 
	Após o desenvolvimento desse trabalho prático e da implementação do programa, ficou bem claro que era necessário a integração de duas partes muito importantes para a resolução do problema proposto. Uma delas era a implementação da estrutura de dados que fosse mais adequada em cada parte, e que esta fosse aplicada de forma correta, coesa e funcional para dar suporte a outra parte do trabalho. E essa outra parte era desenvolver um sistema para encriptação e desencriptação para ajudar a Aliança Rebelde, se utilizando das estruturas de dados que foram previamente criadas e implementadas na primeira parte, de forma a realmente resolver o problema que foi proposto. Assim, com a realização desse trabalho se mostrou evidente que não é suficiente apenas saber implementar uma estrutura de dados, mas saber usá-la e adaptá-la da melhor forma possível de forma a resolver um problema. E também foi necessário a criação de algoritmos para que navegar entre as opções necessárias para controlar o fluxo do programa realizar as operações que eram necessárias. Sendo elas, a inserção de novas palavras, a encriptação, a decriptação e a substituição de uma palavra por outra palavra. 
	A realização de testes para verificar se todas as partes estavam funcionando corretamente também foi fundamental para a realização desse trabalho. Com a execução desse trabalho, ficou evidente a importância da realização de testes para o aperfeiçoamento do programa e para também encontrar melhor os erros e depurar o código.
**6. Bibliografia
Ziviani, N. (2006). Projetos de Algoritmos com Implementações em Java e C++: Capítulo 3: Estruturas de Dados Básicas. Editora Cengage.
CHAIMOWICZ, Luiz e PRATES, Raquel. Slides da disciplina Estrutura de Dados. Departamento de Ciência da Computação. Universidade Federal de Minas Gerais. 2020
Szwarcfiter, J.; Markezon, L. Estruturas de Dados e seus Algoritmos, 3a. ed. LTC. Cap. 4
